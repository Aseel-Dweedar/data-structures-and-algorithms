/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import java.util.ArrayList;
import java.util.List;

public class App {

    public static void main(String[] args) {

        BinaryTree<Integer> newTree = new BinaryTree<>(new Node<>(5));
        Node<Integer> node1 = new Node<>(2);
        Node<Integer> node2 = new Node<>(3);
        Node<Integer> node3 = new Node<>(1, node1, node2);
        Node<Integer> node5 = new Node<>(6);
        Node<Integer> node4 = new Node<>(4, node5, null);
        newTree.root.rightChild = node4;
        newTree.root.leftChild = node3;

        BinaryTree<Integer> newTree1 = new BinaryTree<>(new Node<>(5));
        Node<Integer> node11 = new Node<>(2);
        Node<Integer> node22 = new Node<>(3);
        Node<Integer> node33 = new Node<>(1, node11, node22);
//        Node<Integer> node55 = new Node<>(6);
//        Node<Integer> node44 = new Node<>(4, node55, null);
//        newTree1.root.rightChild = new Node(4);
        newTree1.root.leftChild = node33;

        System.out.println(newTree.preOrder(newTree.root));
//        System.out.println(newTree1.preOrder(newTree1.root));
        System.out.println(newTree1.preOrder(MergeTrees(newTree.root,newTree1.root)));



//        System.out.println(newTree.preOrder(newTree.root));
//        System.out.println(newTree.maximumValue());
//        System.out.println("==================================");
//        System.out.println(newTree.inOrder(newTree.root));
//        System.out.println("==================================");
//        System.out.println(newTree.postOrder(newTree.root));
//        System.out.println("==================================");
//        System.out.println(newTree.toString());
//        System.out.println("==================================");

        /* ---------------------------------------------------------------------------- */

        BinarySearchTree binarySearchTree = new BinarySearchTree(new Node<>(23));

        Node<Integer> searchNode0 = new Node<>(22);
        Node<Integer> searchNode1 = new Node<>(4);
        Node<Integer> searchNode2 = new Node<>(16, null, searchNode0);
        Node<Integer> searchNode3 = new Node<>(8, searchNode1, searchNode2);
        Node<Integer> searchNode5 = new Node<>(27);
        Node<Integer> searchNode7 = new Node<>(105);
        Node<Integer> searchNode6 = new Node<>(85, null, searchNode7);
        Node<Integer> searchNode4 = new Node<>(42, searchNode5, searchNode6);
        binarySearchTree.root.leftChild = searchNode3;
        binarySearchTree.root.rightChild = searchNode4;


        binarySearchTree.add(15);
        binarySearchTree.add(9);
        binarySearchTree.add(28);
        binarySearchTree.add(28);
        binarySearchTree.add(-1);
//        System.out.println(binarySearchTree.preOrder(binarySearchTree.root));
//        System.out.println(binarySearchTree.maximumValue());
//        System.out.println("==================================");
//        System.out.println(binarySearchTree.inOrder(binarySearchTree.root));
//        System.out.println("==================================");
//        System.out.println(binarySearchTree.postOrder(binarySearchTree.root));
//        System.out.println("==================================");
//        System.out.println("False the result is : " + binarySearchTree.contains(7));
//        System.out.println("True the result is : " + binarySearchTree.contains(105));
//        System.out.println("False the result is : " + binarySearchTree.contains(-15));
//        System.out.println("True the result is : " + binarySearchTree.contains(-1));
//        System.out.println("True the result is : " + binarySearchTree.contains(23));

        /* ---------------------------------------------------------------------------- */

//        System.out.println(breadthFirst(newTree));
//        System.out.println(breadthFirst(binarySearchTree));

        Node<Integer> root = new Node<Integer>(0);
        root.child.add(new Node(2));
        root.child.add(new Node(3));
        root.child.add(new Node(5));
        root.child.get(0).child.add(new Node(12));
        root.child.get(0).child.add(new Node(22));
        root.child.get(0).child.add(new Node(15));
//        System.out.println(treeFizzBuzz(root));
    }

    static Node MergeTrees(Node<Integer> t1, Node<Integer> t2) {
        if (t1 == null) return t2;
        if (t2 == null) return t1;
        t1.value += t2.value;
        t1.leftChild = MergeTrees(t1.leftChild, t2.leftChild);
        t1.rightChild = MergeTrees(t1.rightChild, t2.rightChild);
        return t1;
    }

    Node sortedArrayToBST(int arr[], int start, int end) {
        if (start > end) return null;
        int mid = (start + end) / 2;
        Node node = new Node(arr[mid]);
        node.leftChild = sortedArrayToBST(arr, start, mid - 1);
        node.rightChild = sortedArrayToBST(arr, mid + 1, end);
        return node;
    }

    public Node search(Node<Integer> root, int value) {
        if (root==null || root.value == value)return root;
        if (root.value < value) return search(root.rightChild, value);
        return search(root.leftChild, value);
    }

    boolean identicalTrees(Node a, Node b) {
        if (a == null && b == null) return true;
        if (a != null && b != null)
            return (a.value == b.value && identicalTrees(a.leftChild, b.leftChild) && identicalTrees(a.rightChild, b.rightChild));
        return false;
    }



//    public static Node mereg(Node<Integer> t1 , Node<Integer> t2){
//        if (t1 == null && t2 == null) return null;
//        int value =  (t1 != null ? t1.value : 0 ) + (t2 != null ? t2.value : 0);
//        Node newTree = new Node<Integer>( value);
//        newTree.leftChild = mereg(t1.leftChild!= null? t1.leftChild:null,t2.leftChild!= null? t2.leftChild:null );
//        newTree.rightChild = mereg(t1.rightChild!= null? t1.rightChild:null,t2.rightChild!= null? t2.rightChild:null );
//        return newTree;
//    }

    public static List treeFizzBuzz(Node<Integer> treeRoot) {
        List<String> newList = new ArrayList<>();
        if (treeRoot.value == null) return newList;
        Queue myQueue = new Queue();
        myQueue.enqueue(treeRoot);
        while (!myQueue.isEmpty()) {
            Node<Integer> test = myQueue.dequeue();
            for (int i = 0; i < test.child.size(); i++)
                myQueue.enqueue(test.child.get(i));
            if (test.value % 3 == 0 && test.value % 5 == 0) {
                newList.add("FizzBuzz");
            } else if (test.value % 3 == 0) {
                newList.add("Fizz");
            } else if (test.value % 5 == 0) {
                newList.add("Buzz");
            } else {
                newList.add("\"" + test.value + "\"");
            }
        }
        return newList;
    }

    public static ArrayList<Integer> breadthFirst(BinaryTree<Integer> binaryTree) {
        if (binaryTree.root == null) return null;
        ArrayList<Integer> breadthFirstList = new ArrayList<>();
        Queue<Integer> myQueue = new Queue<>();
        myQueue.enqueue(binaryTree.root);
        while (!myQueue.isEmpty()) {
            Node<Integer> front = myQueue.dequeue();
            breadthFirstList.add(front.value);
            if (front.leftChild != null) {
                myQueue.enqueue(front.leftChild);
            }
            if (front.rightChild != null) {
                myQueue.enqueue(front.rightChild);
            }
        }
        return breadthFirstList;
    }

}
